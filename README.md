# Algorithm-for-dummies
为向我一样呆的人写的算法


## 图的搜索

1. > 二分图的判定给定具有$n$个点的图, 要给图上每个顶点染色, 并且要使相邻的顶点的颜色不同. 问是否能够用最多两种颜色进行染色? 保证没有重边和自环

  思路: 核心思路在于写一个`dfs`, 这是一个带有返回状态的`dfs`, 如果所有当前遍历的所有点都涂色正常, 那么就返回`true`, 这就是第一层; 如果遍历点的过程中, 出现了错误, 我们就返回`false`, 由于所有点的涂色正常我们才返回`true`, 因此只要途中出现一点错误, 我们就要进行返回. 也就是说明一个道理, 唐僧西天取经, 只有到了终点才算成功, 中途取得的小成功都是不计数的, 反而要是退却了, 就会无功而返.
  
2. 最短路径问题

   1. 单源最短路径问题(Bellman-Ford算法)

      固定一个起点, 求它到其它所有点的最短路径问题. 终端也固定的问题叫做两点之间最短路问题. 记从起点$s$出发到顶点$i$的最短距离为$d[i]$, 则下述等式成立
      $$
      d[i] = min \{ d[j] +(从j到i的边的权值) e(j, i) \in E \}
      $$
      由于更新每个节点的时候都需要遍历一次所有的边, 因此算法复杂度为$O(|V| \times |E|)$

   2. **Dijkstra**算法

      首先找到距离最短的已经确定的点, 从它出发更新最短距离, 最开始最短的点肯定是从起点开始的直达最短.
      
      这种算法的思路第一种是直接每次找到当前一次迭代最小的, 需要进行遍历; 也可以采用优先级队列的方式, 因为可能出现重复计数的情况, 所以要有检测的情况, 也就是更新的先后顺序.
   
   复杂度分析: Bell-Ford算法需要遍历所有的边来更新所有的顶点, 因此复杂度为$O(|V| \times |E|)$, Dijkstra算法更新`V`个点, 每次都需要遍历所有的点找到最下, 因此复杂度为$O(|V|^2)$, 但是如果采用优先级队列优化, 得到结果为$O(|E| \log|V|)$
   
3. 任意两点之间最短路径问题

   求解所有两点之间的最短路问题叫做任意两点间的最短路径问题. 采用`DP`算法, 只使用顶点$0  - k$和$i$, $j$的情况下, 记录$i$到$j$的最短长度为$d[k+1][i][j] $. $k = -1$时, 认为只使用i, j, 所以d[0][i][j] = cost[i][j]

   算法的思想和将`DFA`转换为`RE`的过程很相似, 也就是说我们需要定义一个中间量`k`, $d[k][i][j]$表示使用的点不超过$k$的从$i$到$j$的最短路径, 所以基础就是$d[0][i][j] = cost[i][j]$, 后面的递推关系就是$d[k][i][j] = min(d[k - 1][i][j], d[k-1][i][k] + dp[k - 1][k][j])$, 由于形成环会极大的增加冗余, 所以这里没有写循环. 计算过程的等价性化为循环为:
   $$
   d[i][j] = \min(d[i][j], d[i][k] + d[k][j]);
   $$

4. 路径还原

   不断寻找前趋节点就可以恢复处最短路， 时间复杂度为$O(|E|)$. 此外采用$prev[j]$来记录最短路上顶点$j$的前趋, 那么就可以在$O(|V|)$的时间复杂度内完成最短路的恢复. 也就是找每个点的前前趋节点, 然后迭代到起点.
   
5. 最小生成树

   * `Prim`算法
   * `Kruskal`算法

   

   
